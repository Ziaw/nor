using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.IO;
using System.Collections.Generic;
using System.Console;
using System.Linq;
using System.Reflection;
using NRails;
using NRails.Migrations;
using NRails.Console;

module Program
{
  public variant MigrationMode 
  {
      | CompiledAssembly {assemblyFile : string}
      | RawFiles { fileList : list[string]}
      | NotSet
  }

  mutable migrationMode : MigrationMode = MigrationMode.NotSet();
  
  
  Main() : void
  {
      mutable command : string;
      mutable args = [];
      
      def migrationPathHandler(c)
      {
        def files = Directory.GetFiles(c, "*.n").ToNList();
        migrationMode = MigrationMode.RawFiles(files);
      }
      
      def options = [
        Getopt.CliOption.String(name = "--migration-assembly",
            aliases = ["-ma"],
            handler = (c) =>
            {
                migrationMode = MigrationMode.CompiledAssembly(c);
            }
        ),
        Getopt.CliOption.String(name = "--migrations-path",
            aliases = ["-mp"],
            handler = migrationPathHandler,
        ),
        Getopt.CliOption.NonOption(name = "command",
            aliases = [],
            handler = (c) =>
            {
                if (command == null)
                    command = c;
                else
                    args = c :: args;
            }
        )
      ];

      Getopt.Parse(options);
      args = args.Rev();
      
      match (command)
      {
          | "migrate" => 
          {
              when (migrationMode is MigrationMode.NotSet)
              {
                  migrationPathHandler("Migrations")
              }
              Migrate(args);
          }
          | _ => Console.WriteLine("Valid commands: migrate.");
      }
  }
  
  Migrate(_args : list[string]) : void
  {
      def ma = match (migrationMode)
      {
          | MigrationMode.CompiledAssembly(migrationAssmbly) =>
              Assembly.LoadFile(Path.GetFullPath(migrationAssmbly));
          | MigrationMode.RawFiles(files) =>
              MigrationCompiler.Compile(files);
          | NotSet =>
              throw ArgumentException();
      }

      def migrationTypes = ma.GetTypes().Filter(t => t.IsSubclassOf(typeof(MigrationBase)));
      
      def migrator = Migrator(Engine.Instance);
      
      def makeMigration(migrationType)
      {
          Activator.CreateInstance(migrationType) :> IMigration;
      }
      
      migrator.Migrate(migrationTypes.Map(makeMigration));
  }
}