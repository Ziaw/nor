using Nemerle;
using Nemerle.Collections;
using Nemerle.Compiler;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler.Parsetree;

using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using NRails;
using NRails.Database.Schema;
using BLToolkit.Mapping;

namespace NRails.Macros.Model
{
    [Nemerle.MacroUsage (Nemerle.MacroPhase.BeforeInheritance, Nemerle.MacroTargets.Class,
                     Inherited = false)]
    public macro Model(t : TypeBuilder, params args : array[expr])
    {
      ModelImpl.RegisterModelType(t, args);
    }

    [Nemerle.MacroUsage (Nemerle.MacroPhase.WithTypedMembers, Nemerle.MacroTargets.Class,
                     Inherited = false)]
    public macro Model(t : TypeBuilder, params args : array[expr])
    {
        ModelImpl.GenerateColumns(t, args);
    }

    internal module ModelImpl
    {
        public GetArg(args : array[PExpr], par : string) : string
        {
            if (args == null)
                null
            else
            {
                def getAll(args)
                {
                | PExpr.Assign(PExpr.Ref(para), PExpr.Literal(Literal.String(value))) :: tail when para.Id == par => value :: getAll(tail)
                | _ => []
                }

                def tt = getAll(args.ToNList());

                match (tt)
                {
                | value :: [] => value
                | [] => null
                | _ => Message.FatalError($"Multiple '$par' in model params");
                }
            }
        }

      public RegisterModelType(t : TypeBuilder, args : array[PExpr]) : void
      {
        def name = GetArg(args, "Table") ?? t.Name;
        DatabaseManagerImpl.RegisterModelType(t, name, t.FullName);
      }

      public GenerateColumns(t : TypeBuilder, args : array[PExpr]) : void
      {
          def engine = t.Manager.GetNRailsEngine();
          try 
          {
            def tableName = GetArg(args, "Table") ?? t.Name;
            def table = engine.GetTable(tableName);
            
            when (table == null)
            {
               def msg = $"table $(t.Name) not found, env: '$(engine.Cfg.Env)'";
               throw Exception(msg);
            }
            
            t.GetModifiers().AddCustomAttribute(<[  BLToolkit.DataAccess.TableName($(table.Name : string)) ]>);

            def hintBuilder = StringBuilder();

            def existingProperties = t.GetProperties().Map(_.Name);
            
            foreach (col : TableColumnSchema in table.Columns)
            {
                // todo : проверка должна идти по атрибутам тулкита, 
                // а не по именам свойств
                unless (existingProperties.Any(p => p == col.Name))
                {
                    def key = table.Keys.Any(t => t.Columns == col.Name && t.KeyType == ConstraintType.KeyForeign);

                    def clrType = col.Type.Type;
                    def nemerleType = regexp match (clrType.FullName)
                    {
                        | @"^(?<type>.+)\[\]$" => def elem = PExpr.FromQualifiedIdentifier(t.Manager, @type); <[ array[$elem] ]>;
                        | _ => PExpr.FromQualifiedIdentifier(t.Manager, clrType.FullName);
                    }
                    def propName = $"$(col.Name)" + if (key) "_Id" else string.Empty;
                    def fieldMemberName = $"_$(propName)";
                   
                    t.Define(<[decl: 
                        private mutable $(fieldMemberName : dyn) : $nemerleType; 
                    ]>);
                    t.Define(<[decl: 
                        [BLToolkit.Mapping.MapField($(col.Name : string))] 
                        public $(propName : dyn) : $nemerleType
                        {
                            get { $(fieldMemberName : dyn); }
                            set { $(fieldMemberName : dyn) = value; }
                        }
                    ]>);

                    _ = hintBuilder.Append($"$(propName) : $(nemerleType)\n");
                }
            }

            foreach (key in table.Keys.Where(t => !string.IsNullOrEmpty(t.RelTable)))
            {
              def typeName = DatabaseManagerImpl.GetTypeForTable(t, key.RelTable);
              def propType = PExpr.FromQualifiedIdentifier(t.Manager, typeName);

              if (propType != null)
              {
                def propName = typeName.Substring(typeName.LastIndexOf('.')+1);
                def fieldMemberName = $"_$(propName)";
                def keyName = $"$(key.Columns)_Id";

                t.Define(<[decl: 
                    private mutable $(fieldMemberName : dyn) : $propType; 
                ]>);
                t.Define(<[decl: 
                  [BLToolkit.Mapping.Association(ThisKey = $(keyName : string), OtherKey = $(key.RelColumns : string))] 
                  public $(propName : dyn) : $propType
                  {
                      get { $(fieldMemberName : dyn); }
                      private set { $(fieldMemberName : dyn) = value; }
                  }
                ]>);
                _ = hintBuilder.Append($"$propName : $typeName\n");
              }
              else
                _ = hintBuilder.Append($"can't find type for table $(key.RelTable)\n");
            }

            unless (hintBuilder.Length == 0)
                Message.Hint("\n" + hintBuilder.ToString())
          }
          catch 
          {
             | e => Message.Error($"$(t.Name) model error: $(e.ToString())");
          }
      }
  }
}
