using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using Nemerle.Assertions;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;
using Nemerle.Compiler.Typedtree;
using Nemerle.Imperative;
using System.Web.Mvc;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using System.IO;

namespace NRails.Macros
{
  module InitConstants
  {
    mutable mvcBuilder : TypeBuilder;
    
    public Init(_ : Typer, manager: ManagerClass, phase : Phase) : void
    {
       def nss = manager.CoreEnv.NameTree.NamespaceTree;

       mvcBuilder = match(phase, mvcBuilder) 
       {
           | (_, null)
           | (Phase.BeforeInheritance, _) => 
               manager.CoreEnv.Define(<[decl:
                public module MVC
                {
                }
               ]>)
           | _ => mvcBuilder;
       }
       
       foreach (tb in nss.GetTypeBuilders())
       {
           | tb when (isController(tb)) =>
              ProcessController(phase, tb, mvcBuilder);
           | _ => ()
       }

       when (phase == Phase.WithTypedMembers)
       {
           ProcessContent(mvcBuilder);
           ProcessScripts(mvcBuilder);
           hideEquals(mvcBuilder);
           mvcBuilder.Compile();
           mvcBuilder = null
       }
    }

    static separators = array [Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar];
    
    fixFieldName(fileName : string) : string
    {
        def name = fileName.Replace('.', '_').Replace('-', '_');
        match (char.IsLetter(name[0]))
        {
            | true => name
            | false => $"_$name"
        }
    }

    ProcessFiles(getFilesInfo : string -> list[string*string], fileNameFixer : string -> string, dirName : string, tb : TypeBuilder) : void
    {
        def projectPath = Path.GetDirectoryName(tb.Manager.Options.ProjectPath);
        def path = Path.Combine(projectPath, dirName);

        when (Directory.Exists(path))
        {
            def name = fixFieldName(dirName.Split(separators).Last());

            def helperType = tb.DefineNestedType(<[decl: 
                public module $(name : dyn) 
                {
                }
            ]>);

            def makeDecl(field)
            {
                def (field, value) = field;
                def field = fixFieldName(Path.GetFileName(field));

                assert(value.Length > projectPath.Length + 1);

                def relName = value.Substring(projectPath.Length + 1);
                def value = $"~/$relName".Replace('\\', '/'); // !!
                <[decl:
                    public static $(field : dyn) : string = $(value : string);
                ]>
            }

            getFilesInfo(path).Iter(f => {
                def (fileName, value) = f;
                def fixed = (fileNameFixer(fileName), value);
                def decl = makeDecl(fixed);
                helperType.Define(decl);
            });

            Directory.GetDirectories(path).Iter(d => ProcessFiles(getFilesInfo, fileNameFixer, Path.Combine(dirName, Path.GetFileName(d)), helperType));

            hideEquals(helperType);
            helperType.Compile();
        }
    }

    ProcessContent(tb : TypeBuilder) : void
    {
        def fileNameFixer(fileName)
        {
            fileName
        }
        def getFilesInfo(path)
        {
            Directory.GetFiles(path).Map(t => (t, t)).ToNList()
        }
        ProcessFiles(getFilesInfo, fileNameFixer, "Content", tb)
    }

    ProcessScripts(tb : TypeBuilder) : void
    {
        def fixFileName(fileName)
        {
            regexp match (fileName)
            {
                | @"^(?<name>.+)\.js$" => name
                | _ => fileName
            }
        }
        def getFilesInfo(path)
        {
            def files = NList.ToList(Directory.GetFiles(path).OrderByDescending(f => f.Length));

            def isDebug = tb.Manager.Options.IsConstantDefined("DEBUG");
            def matchFiles(files)
            {
                | file :: tail =>
                    regexp match (file)
                    {
                        | @"^(?<name>.+)(\-vsdoc|\.debug)\.js$" =>
                            def shortname = $"$name.js";
                            match (tail.Contains(shortname))
                            {
                                | true => (shortname, if (isDebug) file else shortname) :: matchFiles(tail.Remove(shortname))
                                | false => (file, file) :: matchFiles(tail)
                            }
                        | _ => (file, file) :: matchFiles(tail)
                    }
                | [] => []
            }
            matchFiles(files)
        }
        ProcessFiles(getFilesInfo, fixFileName, "Scripts", tb)
    }

    controllerPredicate : Regex = Regex("Controller$");
    isController(tb : TypeBuilder) : bool
    {
        controllerPredicate.IsMatch(tb.Name)
    }
    
    ProcessController(phase : Phase, controllerBilder : TypeBuilder, mvcBuilder : TypeBuilder) : void
    {
        match (phase)
        {
            | Phase.WithTypedMembers => 
                def name = controllerPredicate.Replace(controllerBilder.Name, String.Empty);
                
                def makeActionMethods(actionMethod)
                {
                    def methodName = actionMethod.Name;
                    def parms = actionMethod.GetParameters().Map(m => m.AsParsed());
                    
                    def simpleMethod = <[decl:
                        public $(methodName : dyn)() : INRActionResult
                        {
                            NRActionResult(String.Empty, $(name : string), $(methodName : string))
                        }
                    ]>;
                    
                    def parametrizedMethod(parms)
                    {
                        def parametrizedBody = 
                            <[def r = NRActionResult(String.Empty, $(name : string), $(methodName : string));]> 
                            :: parms.Map(m => <[r.RouteValueDictionary.Add($(m.Name : string), $(m.Name : dyn));]>);
                        def body = parametrizedBody + [<[r]>];
                        <[decl:
                            public $(methodName : dyn)(..$(parms)) : INRActionResult
                            {
                                ..$body;
                            }
                        ]>
                    }
                    
                    match (parms)
                    {
                        | [] => [simpleMethod]
                        | _  => [simpleMethod, parametrizedMethod(parms)]
                    }
                }
                
                def methods = controllerBilder.GetMethods()
                    .Filter(m => m.ReturnType.GetSystemType().Name == "ActionResult")
                    .Map(makeActionMethods)
                    .Flatten();
                    
                def removeDups(_)
                {
                  | x :: tail =>
                    match (tail.Find(m => m.Name == x.Name && m.header.Parameters.Length == x.header.Parameters.Length))
                    {
                      | Some => removeDups(tail)
                      | None => x :: removeDups(tail)
                    }
                  | [] => [] 
                }
                
                def methods = removeDups(methods);

                def injectMethods(t)
                {
                    foreach (method in methods)
                        t.Define(method);
                    
                    hideEquals(t);
                }
                
                def helperType = mvcBuilder.DefineNestedType(<[decl: 
                    public module $(name : dyn) 
                    {
                    }
                ]>);
                
                def actionType = controllerBilder.DefineNestedType(<[decl:
                    public module Actions
                    {
                    }
                ]>);
                
                [helperType, actionType].Iter(t => {
                    injectMethods(t);
                    t.Compile()
                })
            | _ => ()
        }

    }

    // hiding unused methods from intellesense list
    hideEquals(t : TypeBuilder) : void
    {
        t.Define(<[decl: new private Equals(_ : object, _ : object) : bool { true } ]>);
        t.Define(<[decl: new private ReferenceEquals(_ : object, _ : object) : bool { true } ]>);
    }
  }
}
