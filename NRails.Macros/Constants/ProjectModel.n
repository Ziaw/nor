using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using NRails;

using System;
using System.Collections.Generic;
using System.Linq;

namespace NRails.Macros
{
    public module Manager 
    {
        T4MVCNamespace = "T4MVC";
        ControllerSuffix = "Controller";

        public mutable AppRoot : string;
        public mutable Areas : HashSet[AreaInfo];
        public mutable DefaultArea : AreaInfo;
        public mutable ResultTypes : Dictionary[string, ResultTypeInfo];
        public mutable HtmlStringType : string;
        public mutable HelpersPrefix : string;
        

        GetControllers() : IEnumerable[ControllerInfo] 
        {
            def controllers = List.[ControllerInfo]();

            foreach (area in Areas) 
            {
                controllers.AddRange(area.GetControllers());
            }

            controllers;
        }

        GetAbstractControllers() : IEnumerable[ControllerInfo] 
        {
            def controllers = List.[ControllerInfo]();

            foreach (area in Areas) 
            {
                controllers.AddRange(area.GetAbstractControllers());
            }

            controllers;
        }

        PrepareDataToRender() : void 
        {
            Areas = HashSet.[AreaInfo]();
            ResultTypes = Dictionary.[string, ResultTypeInfo]();

            AppRoot = Engine.CompileTimeInstance.RootPath;

            ProcessAreas(Project);
        }


        ProcessAreas(areas : List[AreaInfo]) : void
        {
            // Process the default area
            ProcessArea(project.ProjectItems, null);

            // Get the Areas folder
            ProjectItem areaProjectItem = GetProjectItem(project, AreasFolder);
            if (areaProjectItem == null)
                return;

            foreach (ProjectItem item in areaProjectItem.ProjectItems) {
                if (IsFolder(item)) {
                    ProcessArea(item.ProjectItems, item.Name);
                }
            }
        }

        ProcessArea(areaFolderItems : ProjectItems, name : string) : void
        {
            def area = AreaInfo();
            area.Name = name;
            
            ProcessAreaControllers(areaFolderItems, area);
            ProcessAreaViews(areaFolderItems, area);
            Areas.Add(area);

            when (String.IsNullOrEmpty(name))
                DefaultArea = area;
        }

        ProcessAreaControllers(areaFolderItems : ProjectItems , area : AreaInfo ) : void 
        {
            // Get area Controllers folder
            def controllerProjectItem = GetProjectItem(areaFolderItems, ControllersFolder);
    
            unless (controllerProjectItem == null)
                ProcessControllersRecursive(controllerProjectItem, area);
        }

        ProcessAreaViews(areaFolderItems : ProjectItems, area : AreaInfo) : void {
            // Get area Views folder
            def viewsProjectItem = GetProjectItem(areaFolderItems, ViewsRootFolder);
            unless (viewsProjectItem == null)
                ProcessAllViews(viewsProjectItem, area);
        }

        ProcessControllersRecursive(projectItem : ProjectItem, area : AreaInfo): void
        {
            // Recurse into all the sub-items (both files and folder can have some - e.g. .tt files)
            foreach (item in projectItem.ProjectItems) {
                ProcessControllersRecursive(item, area);
            }

            when (projectItem.FileCodeModel != null) {
                def controllerLastWriteTime = File.GetLastWriteTime(projectItem.get_FileNames(0));
                foreach (@type in projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>()) {
                    ProcessControllerType(@type, area, controllerLastWriteTime);
                }
                // Process all the elements that are namespaces
                foreach (ns in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>()) {
                    foreach (@type in ns.Members.OfType<CodeClass2>()) {
                        ProcessControllerType(@type, area, controllerLastWriteTime);
                    }
                }
            }
        }

        ProcessControllerType(@type : CodeClass2, area : AreaInfo , controllerLastWriteTime : DateTime) : void {
            // Only process types that end with Controller
            // REVIEW: this check is not super reliable. Should look at base class.
            when (@type.Name.EndsWith(ControllerSuffix, StringComparison.OrdinalIgnoreCase) && ! @type.IsGeneric)
            {
                // Collect misc info about the controller class and add it to the collection
                def controllerInfo = ControllerInfo
                (
                    Area = area,
                    Namespace = if (@type.Namespace != null) @type.Namespace.Name else String.Empty,
                    ClassName = @type.Name
                );

                // Check if the controller has changed since the generated file was last created
                def lastGenerationTime = File.GetLastWriteTime(controllerInfo.GeneratedFileFullPath);
                when (lastGenerationTime > controllerLastWriteTime) {
                    controllerInfo.GeneratedCodeIsUpToDate = true;
                }

                // Either process new ControllerInfo or integrate results into existing object for partially defined controllers
                def target = if (area.Controllers.Add(controllerInfo)) controllerInfo else area.Controllers.First(c => c.Equals(controllerInfo));
                target.HasExplicitConstructor |= HasExplicitConstructor(@type);
                target.HasExplicitDefaultConstructor |= HasExplicitDefaultConstructor(@type);

                if (@type.IsAbstract) {
                    // If it's abstract, set a flag and don't process action methods (derived classes will)
                    target.IsAbstract = true;
                }
                else {
                    // Process all the action methods in the controller
                    ProcessControllerActionMethods(target, @type);
                }
            }
        }

        ProcessControllerActionMethods(controllerInfo : ControllerInfo, current : CodeClass2) : void
        {

            // We want to process not just the controller class itself, but also its parents, as they
            // may themselves define actions
            for (@type = current; @type != null && @type.FullName != "System.Web.Mvc.Controller"; @type = @type.Bases.Item(1) :> CodeClass2) 
            {

                foreach (method in GetMethods(@type)) {
                    // Ignore non-public methods
                    when (method.Access != vsCMAccess.vsCMAccessPublic)
                        continue;

                    // Ignore methods that are marked as not being actions
                    when (GetAttribute(method.Attributes, "System.Web.Mvc.NonActionAttribute") != null)
                        continue;

                    // This takes care of avoiding generic types which cause method.@type.CodeType to blow up
                    when (method.@type.TypeKind != vsCMTypeRef.vsCMTypeRefCodeType)
                        continue;

                    // We only support action methods that return an ActionResult derived @type
                    when (!method.@type.CodeType.get_IsDerivedFrom("System.Web.Mvc.ActionResult")) {
                        Warning(String.Format("{0} doesn't support {1}.{2} because it doesn't return a supported ActionResult @type", T4FileName, @type.Name, method.Name));
                        continue;
                    }

                    // If we haven't yet seen this return @type, keep track of it
                    when (!ResultTypes.ContainsKey(method.@type.CodeType.Name)) {
                        def resTypeInfo = ResultTypeInfo(method.@type.CodeType);

                        ResultTypes[method.@type.CodeType.Name] = resTypeInfo;
                    }

                    // Make sure the method is virtual
                    if (!method.CanOverride && method.OverrideKind != vsCMOverrideKind.vsCMOverrideKindOverride) {
                        try {
                            method.CanOverride = true;
                        }
                        catch {
                            // If we couldn't make it virtual, give a warning and skip it
                            Warning(String.Format("{0} was not able to make the action method {1}.{2} virtual. Please change it manually if possible", T4FileName, @type.Name, method.Name));
                            continue;
                        }
                        Warning(String.Format("{0} changed the action method {1}.{2} to be virtual", T4FileName, @type.Name, method.Name));
                    }

                    // Collect misc info about the action method and add it to the collection
                    controllerInfo.ActionMethods.Add(new ActionMethodInfo(method));
                }
            }
        }

        ProcessAllViews(viewsProjectItem : ProjectItem, area : AreaInfo) : void {
            // Go through all the sub-folders in the Views folder
            foreach (item in viewsProjectItem.ProjectItems) {

                // We only care about sub-folders, not files
                when (!IsFolder(item))
                    continue;

                // Find the controller for this view folder
                def controller = area.Controllers.SingleOrDefault(c => c.Name.Equals(item.Name, StringComparison.OrdinalIgnoreCase));

                when (controller == null) {
                    // If it doesn't match a controller, treat as a pseudo-controller for consistency
                    controller = ControllerInfo(
                        Area = area,
                        NotRealController = true,
                        Namespace = MakeClassName(T4MVCNamespace, area.Name),
                        ClassName = item.Name + ControllerSuffix
                    );
                    area.Controllers.Add(controller);
                }

                AddViewsRecursive(item.ProjectItems, controller.ViewsFolder);
            }
        }

        AddViewsRecursive(items : ProjectItems, viewsFolder : ViewsFolderInfo) : void 
        {
            // Go through all the files in the subfolder to get the view names
            foreach (item in items) {
                if (item.Kind == Constants.vsProjectItemKindPhysicalFile) {
                    when (Path.GetExtension(item.Name).Equals(".master", StringComparison.OrdinalIgnoreCase))
                        continue;	// ignore master files
                    viewsFolder.AddView(item);
                }
                else when (item.Kind == Constants.vsProjectItemKindPhysicalFolder) {
                    def folderName = Path.GetFileName(item.Name);
                    when (folderName.Equals("App_LocalResources", StringComparison.OrdinalIgnoreCase))
                        continue;
                    def subViewFolder = ViewsFolderInfo(Name = folderName);
                    viewsFolder.SubFolders.Add(subViewFolder);
                    AddViewsRecursive(item.ProjectItems, subViewFolder);
                }
            }
        }

        RenderViewsRecursive(viewsFolder : ViewsFolderInfo, controller : ControllerInfo) : void 
        {

    // For each view, generate a readonly string
    foreach (var viewPair in viewsFolder.Views) {
        WriteLine("public readonly string " + EscapeID(Sanitize(viewPair.Key)) + " = \"" + viewPair.Value + "\";");
    }

    // For each sub folder, generate a class and recurse
    foreach (var subFolder in viewsFolder.SubFolders) {
        string newClassName = Sanitize(subFolder.Name);#>
static readonly _<#=newClassName#> s_<#=newClassName#> = new _<#=newClassName#>();
public _<#=newClassName#> <#=EscapeID(newClassName)#> { get { return s_<#=newClassName#>; } }
public partial class _<#=newClassName#>{
<#+
PushIndent("    ");
RenderViewsRecursive(subFolder, controller);
PopIndent();

WriteLine("}");
    }
}

void ProcessStaticFiles(Project project, string folder) {

    ProjectItem folderProjectItem = GetProjectItem(project, folder);
    if (folderProjectItem != null) {
        ProcessStaticFilesRecursive(folderProjectItem, "~");
    }
}

void ProcessStaticFilesRecursive(ProjectItem projectItem, string path) {

    if (IsFolder(projectItem)) { #>
    [<#= GeneratedCode #>, DebuggerNonUserCode]
    public static class <#=EscapeID(Sanitize(projectItem.Name)) #> {
        private const string URLPATH = "<#=path#>/<#=projectItem.Name#>";
        public static string Url() { return T4MVCHelpers.ProcessVirtualPath(URLPATH); }
        public static string Url(string fileName) { return T4MVCHelpers.ProcessVirtualPath(URLPATH + "/" + fileName); }
<#+
PushIndent("    ");

// Recurse into all the items in the folder
foreach (ProjectItem item in projectItem.ProjectItems) {
    ProcessStaticFilesRecursive(item, path + "/" + projectItem.Name);
}

PopIndent();
#>
    }

<#+
}
    else { #>
<#+
if (!ExcludedStaticFileExtensions.Any(extension => projectItem.Name.EndsWith(extension, StringComparison.OrdinalIgnoreCase))) {
    // if it's a non-minified javascript file
    if (projectItem.Name.EndsWith(".js") && !projectItem.Name.EndsWith(".min.js")) { 
        if (AddTimestampToStaticLinks) { #>
    public static readonly string <#=Sanitize(projectItem.Name)#> = T4MVCHelpers.IsProduction() && T4Extensions.FileExists(URLPATH + "/<#=projectItem.Name.Replace(".js", ".min.js")#>") ? Url("<#=projectItem.Name.Replace(".js", ".min.js")#>")+"?"+T4Extensions.TimestampString(URLPATH + "/<#=projectItem.Name#>") : Url("<#=projectItem.Name#>")+"?"+T4Extensions.TimestampString(URLPATH + "/<#=projectItem.Name#>");
        <#+} else {#>
    public static readonly string <#=Sanitize(projectItem.Name)#> = T4MVCHelpers.IsProduction() && T4Extensions.FileExists(URLPATH + "/<#=projectItem.Name.Replace(".js", ".min.js")#>") ? Url("<#=projectItem.Name.Replace(".js", ".min.js")#>") : Url("<#=projectItem.Name#>");
        <#+}  #>          
<#+}
    else if (AddTimestampToStaticLinks) { #>
    public static readonly string <#=Sanitize(projectItem.Name)#> = Url("<#=projectItem.Name#>")+"?"+T4Extensions.TimestampString(URLPATH + "/<#=projectItem.Name#>");
<#+}
    else { #>
    public static readonly string <#=Sanitize(projectItem.Name)#> = Url("<#=projectItem.Name#>");
<#+}
} #>

// Non folder items may also have children (virtual folders, Class.cs -> Class.Designer.cs, template output)
// Just register them on the same path as their parent item
foreach (ProjectItem item in projectItem.ProjectItems) {
    ProcessStaticFilesRecursive(item, path);
}
    }
}}

    GetProjectItem(project : Project, name : string) : ProjectItem 
    {
        GetProjectItem(project.ProjectItems, name);
    }

    GetProjectItem(items : ProjectItems, subPath : string) : ProjectItem 
    {
/*        ProjectItem current = null;
        foreach (string name in subPath.Split('\\')) {
            try {
                // ProjectItems.Item() throws when it doesn't exist, so catch the exception
                // to return null instead.
                current = items.Item(name);
            }
            catch {
                // If any chunk couldn't be found, fail
                return null;
            }
            items = current.ProjectItems;
        }

        return current;*/ null
    }

    GetVirtualPath(item : ProjectItem) : string 
    {
        def fileFullPath = item.get_FileNames(0);
        when (!fileFullPath.StartsWith(AppRoot, StringComparison.OrdinalIgnoreCase))
            throw Exception(string.Format("File {0} is not under app root {1}. Please report issue.", fileFullPath, AppRoot));

        // Make a virtual path from the physical path
        "~/" + fileFullPath.Substring(AppRoot.Length).Replace('\\', '/');
    }

    ProcessAreaOrControllerName(name : string) : string 
    {
        if (UseLowercaseRoutes) name.ToLowerInvariant() else name;
    }

    // Return all the CodeFunction2 in the CodeElements collection
    GetMethods(codeClass : CodeClass2) : IEnumerable<CodeFunction2> 
    {
        // Only look at regular method (e.g. ignore things like contructors)
        codeClass.Members.OfType<CodeFunction2>()
            .Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionFunction);
    }

    // Check if the class has any explicit constructor
    static bool HasExplicitConstructor(CodeClass2 codeClass) {
        return codeClass.Members.OfType<CodeFunction2>().Any(
            f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
    }

    // Check if the class has a default (i.e. no params) constructor
    static bool HasExplicitDefaultConstructor(CodeClass2 codeClass) {
        return codeClass.Members.OfType<CodeFunction2>().Any(
            f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor && f.Parameters.Count == 0);
    }

    // Find a method with a given name
    static CodeFunction2 GetMethod(CodeClass2 codeClass, string name) {
        return GetMethods(codeClass).FirstOrDefault(f => f.Name == name);
    }

    // Find an attribute of a given type on an attribute collection
    static CodeAttribute2 GetAttribute(CodeElements attributes, string attributeType) {
        for (int i = 1; i <= attributes.Count; i++) {
            var attrib = (CodeAttribute2)attributes.Item(i);
            if (attrib.FullName == attributeType) {
                return attrib;
            }
        }
        return null;
    }

    // Return whether a ProjectItem is a folder and not a file
    IsFolder(item : ProjectItem) : bool  {
        return (item.Kind == Constants.vsProjectItemKindPhysicalFolder);
    }

    MakeClassName(ns : string, classname : string) : string {
        if (String.IsNullOrEmpty(ns))
            classname 
        else if (String.IsNullOrEmpty(classname))
            ns 
        else    
            ns + "." + codeProvider.CreateEscapedIdentifier(classname);
    }

    Sanitize(token : string) : string  {
        // Replace all invalid chars by underscores
        mutable token = Regex.Replace(token, @"[\W\b]", "_", RegexOptions.IgnoreCase);

        // If it starts with a digit, prefix it with an underscore
        token = Regex.Replace(token, @"^\d", @"_$0");

        // Check for reserved words
        // TODO: Clean this up and add other reserved words (keywords, etc)
        when (token == "Url") 
            token = "_Url";

        token;
    }

    EscapeID(id : string) : string 
    {
        codeProvider.CreateEscapedIdentifier(id);
    }



// Data structure to collect data about a method
class FunctionInfo {
    protected CodeFunction2 _method;
    private string _signature;

    public FunctionInfo(CodeFunction2 method) {
        Parameters = new List<MethodParamInfo>();

        // Can be null when an custom ActionResult has no ctor
        if (method == null)
            return;

        _method = method;

        // Build a unique signature for the method, used to avoid duplication
        _signature = method.Name;

        // Process all the parameters
        foreach (var p in method.Parameters.OfType<CodeParameter2>()) {
            string routeNameExpression = "\"" + p.Name + "\"";

            // If there is a [Bind(Prefix = "someName")] attribute, use it
            if (p.InfoLocation != vsCMInfoLocation.vsCMInfoLocationExternal) {
                var attrib = GetAttribute(p.Attributes, "System.Web.Mvc.BindAttribute");
                if (attrib != null) {
                    var arg = attrib.Arguments.OfType<CodeAttributeArgument>().FirstOrDefault(a => a.Name == "Prefix");
                    if (arg != null)
                        routeNameExpression = arg.Value;
                }
            }
            
            Parameters.Add(
                new MethodParamInfo() {
                    Name = p.Name,
                    RouteNameExpression = routeNameExpression,
                    Type = p.Type.AsString
                });
            _signature += "," + p.Type.AsString;
        }
    }

    public string Name { get { return _method.Name; } }
    public string ReturnType { get { return _method.Type.CodeType.Name; } }
    public string ReturnTypeFullName { get { return _method.Type.CodeType.FullName; } }
    public bool IsPublic { get { return _method.Access == vsCMAccess.vsCMAccessPublic; } }
    public List<MethodParamInfo> Parameters { get; private set; }

    // Write out all the parameters as part of a method declaration
    public void WriteFormalParameters(bool first) {
        foreach (var p in Parameters) {
            if (first)
                first = false;
            else
                TT.Write(", ");

            TT.Write(p.Type + " " + p.Name);
        }
    }

    // Pass non-empty param values to make sure the ActionResult ctors don't complain
    // REVIEW: this is a bit dirty
    public void WriteNonEmptyParameterValues(bool first) {
        foreach (var p in Parameters) {
            if (first)
                first = false;
            else
                TT.Write(", ");

            switch (p.Type) {
                case "string":
                    TT.Write("\" \"");
                    break;
                case "byte[]":
                    TT.Write("new byte[0]");
                    break;
                default:
                    TT.Write("default(" + p.Type + ")");
                    break;
            }
        }
    }

    public override bool Equals(object obj) {
        return obj != null && _signature == ((FunctionInfo)obj)._signature;
    }

    public override int GetHashCode() {
        return _signature.GetHashCode();
    }
}

// Data structure to collect data about an action method
class ActionMethodInfo : FunctionInfo {
    public ActionMethodInfo(CodeFunction2 method)
        : base(method) {
        // Normally, the action name is the method name. But if there is an [ActionName] on
        // the method, get the expression from that instead
        ActionNameValueExpression = '"' + Name + '"';
        var attrib = GetAttribute(method.Attributes, "System.Web.Mvc.ActionNameAttribute");
        if (attrib != null) {
            var arg = (CodeAttributeArgument)attrib.Arguments.Item(1);
            ActionNameValueExpression = arg.Value;
        }
    }

    public string ActionName { get { return Name; } }
    public string ActionNameValueExpression { get; set; }
}

// Data about an ActionResult derived type
class ResultTypeInfo {
    CodeType _codeType;
    public ResultTypeInfo(CodeType codeType) {
        _codeType = codeType;

        var ctor = _codeType.Members.OfType<CodeFunction2>().FirstOrDefault(
            f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
        Constructor = new FunctionInfo(ctor);
    }

    public string Name { get { return _codeType.Name; } }
    public string FullName { get { return _codeType.FullName; } }
    public FunctionInfo Constructor { get; set; }
    public IEnumerable<FunctionInfo> AbstractMethods {
        get {
            return _codeType.Members.OfType<CodeFunction2>().Where(
                f => f.MustImplement).Select(f => new FunctionInfo(f));
        }
    }
}

class MethodParamInfo {
    public string Name { get; set; }
    public string RouteNameExpression { get; set; }
    public string Type { get; set; }
}


/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void KeepGeneratedFile(String name) {
        name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
        generatedFileNames.Add(name);
    }
    
    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach (Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach (var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach (String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}
}
