using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;

using NRails.Migrations;

namespace NRails.Macros.Migration
{
  module MigrationImpl
  {
      public Create(_ : Typer, name : PExpr, code : PExpr) : PExpr
      {
          def t = <[ $("t" : usesite) ]>;
          def c = <[ $("c" : usesite) ]>;
          
          <[
            this.CreateTable($(name.ToString() : string), $t => 
            {
                $(CompileColumns(t, c, code, false))
            });
          ]>
      }

      public Change(_ : Typer, name : PExpr, code : PExpr) : PExpr
      {
          // todo: поправить CompileColumn, для изменения существующего поля
          // возможность не указывать тип поля, например:
          // Id : same(len = 20)
          // также нужно продумать ренейм и дроп колонок
          def c = <[ $("c" : usesite) ]>;
          def t = <[ $("t" : usesite) ]>;
          
          
          <[
            this.ChangeTable($(name.ToString() : string), $t => 
            {
                $(CompileColumns(t, c, code, true))
            });
          ]>
      }
      
      variant ParsedAction
      {
          | Create
          | Change
      }
      
      CompileColumns(t : PExpr.Ref, c : PExpr.Ref, code : PExpr, allowChanges : bool) : PExpr
      {
          mutable colNames = Set.[string]();
          
          def checkChangesMode(loc : Location, allowedResult : void -> PExpr)
          {
              if (allowChanges)
                allowedResult()
              else
              {
                Message.Error(loc, "No changes allowed here.");
                <[]>
              }
          }
          
          def newField(name, action) 
          {
              if (colNames.Contains(name.ToString()))
              {
                  Message.Error(name.loc, $"Duplicate column '$name'");
                  <[]>
              }
              else
              {
                  colNames = colNames.Add(name.ToString());
                  action();
              }
          }
          
          def compile(s : PExpr, action) : PExpr
          {
            match (s)          
            {
                | PExpr.MacroCall(name, _, expr) =>
                    match (name.ToString(), expr)
                    {
                        | ("change", [SyntaxElement.Expression(x)]) => 
                            checkChangesMode(s.loc, () => compile(x, ParsedAction.Change()));

                        | ("drop", [SyntaxElement.Expression(x)]) => 
                            checkChangesMode(s.loc, () => 
                                match (x)
                                {
                                    | PExpr.Ref(name) =>
                                       <[ $t.Drop($(name.ToString() : string)) ]>
                                    | _ => Message.Error(x.loc, "Invalid drop syntax"); <[]>
                                });
                        |  ("createindex", [SyntaxElement.Expression(_)]) =>
                            Message.Warning(s.loc, "create index is not implemented."); <[]>
                        |  ("dropindex", [SyntaxElement.Expression(_)]) =>
                            Message.Warning(s.loc, "drop index is not implemented."); <[]>
                        | _ => 
                           Message.Error(s.loc, $"Invalid macro call '$(name.ToString())'");
                           <[]>
                    }
                | <[ $name :> $type_? ]> with isNullable = true
                | <[ $name :> $type_ ]> with isNullable = false =>
                  newField(name, () => CompileReference(t, c, name, type_, isNullable, action));
                  
                
                | <[ $name : $type_?; ]> with (defExpr = null, isNullable = true)
                | <[ $name : $type_; ]> with (defExpr = null, isNullable = false)
                | <[ $name : $type_? = $defExpr; ]> with isNullable = true
                | <[ $name : $type_ = $defExpr; ]> with isNullable = false => 
                  newField(name, () => CompileColumn(t, c, name, type_, defExpr, isNullable, action));

                | x => 
                    Message.Error(x.loc, $"Ivalid field definition $x, $(x.GetType())");
                    <[]>;
            }
          }
          match (code)
          {
              | PExpr.Sequence(seq) => PExpr.Sequence(seq.Map(compile(_, ParsedAction.Create())))
              | x => compile(x, ParsedAction.Create());
          }
      }

      CompileReference(t : PExpr.Ref, _ : PExpr.Ref, name : PExpr, type_ : PExpr, isNullable : bool, action : ParsedAction) : PExpr
      {
          match (action)
          {
              | ParsedAction.Create =>
                  match (type_)
                  {
                      | <[ $type_(pk)]> =>
                        <[ 
                            $t.AddPk($(name.ToString() : string)); 
                            $t.CreateReference($(name.ToString() : string), $(type_.ToString() : string), $(isNullable : bool));
                         ]>
                      | _ => 
                        <[ 
                            $t.CreateReference($(name.ToString() : string), $(type_.ToString() : string), $(isNullable : bool));
                         ]>
                  }
              
              | _ => 
                Message.Error(type_.loc, "Only create references allowed");
                <[]>
          }
      }
      CompileColumn(t : PExpr.Ref, c : PExpr.Ref, name : PExpr, type_ : PExpr, defExpr : PExpr, isNullable : bool, action : ParsedAction) : PExpr
      {
          mutable body = [<[ $c.Name = $(name.ToString() : string);]>];
          mutable pkAction = [<[]>];
          
          def Add(p)   { body = p :: body;}
          def AddPk(p) { pkAction = p :: pkAction;}
          
          def compileParm(parm : PExpr)
          {
              match (parm)
              {
                  | <[ Scale = $(number : int)]>
                  | <[ scale = $(number : int)]> 
                    => Add(<[ $c.DecimalScale = $(number : int); ]>)
                    
                  | <[ Precision = $(number : int)]>
                  | <[ precision = $(number : int)]> 
                    => Add(<[ $c.DecimalPrecision = $(number : int); ]>)
                  
                  | <[ Size = $(number : int)]> 
                  | <[ len = $(number : int)]> 
                  | <[ length = $(number : int)]> 
                  | <[ size = $(number : int)]> 
                  | <[ $(number : int)]> 
                    => Add(<[ $c.Size = $(number : long); ]>)
                  

                  | <[ pk ]> 
                    => AddPk(<[ $t.AddPk($(name.ToString() : string)); ]>);
                  
                  | <[ identity]> with (seed = 1, increment = 1) 
                  | <[ identity($(seed : int), $(increment : int))]> 
                    => Add(<[
                          $c.AutoIncrement = true;
                          $c.Seed = $(seed : int);
                          $c.Increment = $(increment : int);]>);
                  
                          
                  | <[ $x = $_ ]> 
                  | x => Message.Error(x.loc, $"Invalid param '$x'")
              }
          }
          
          match (type_)
          {
            | <[ $typeName(..$parms) ]> 
            | <[ $typeName ]> with parms = [] => 
                def strType = typeName.ToString();
                
                def columnType = MigrationUtils.ColumnTypeFromString(strType);
                
                if (columnType.HasValue)
                {
                    parms.Iter(compileParm);
                    Add(<[ $c.Type = NRails.Database.Schema.ColumnType.$(columnType.Value.ToString() : usesite); ]>);
                    
                    Add(<[ $c.Nullable = $(isNullable : bool); ]>);
                }
                else
                {
                    Message.Error(typeName.loc, $"Invalid type name '$strType'");
                }
          }
          
          match (defExpr)
          {
              | null => {}
              // todo: надо разобраться как вычислять выражения типа даты
              // и преобразовывать их в нужный сиквельный эквивалент (похоже тулкит умеет, глядел мельком)
              | <[ $(x : int) ]> => Add(<[ $c.DefaultValue = $("'"  + x.ToString() + "'": string) ; ]>);
              | <[ $(x : string) ]> => Add(<[ $c.DefaultValue = $("'"  + x + "'": string); ]>);
              | <[ $x ]> => Message.Error(x.loc, "Only string or int default value supported.");
          }
          
          match (action)
          {
              | ParsedAction.Change() =>
                  <[ 
                      $t.Change($(name.ToString() : string), $c => {
                          ..$body
                      });
                      {..$pkAction};
                  ]>;
              | _ =>
                  <[ 
                      $t.Add($c => {
                          ..$body
                      });
                      {..$pkAction};
                  ]>;
          }
      }
  }
}
