using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Spark;
using Spark.Compiler;
using Spark.Compiler.ChunkVisitors;
using Spark.Compiler.NodeVisitors;
using Spark.Parser.Markup;

namespace NRails.Spark
{
  /// <summary>
  /// Description of NRailsExtensionFactory.
  /// </summary>
  public class NRailsExtensionFactory: ISparkExtensionFactory
  {
     public CreateExtension(_context : VisitorContext, node : ElementNode) : ISparkExtension 
     {
         match (node.Name)
         {
             | "match" => MatchExtension(node)
             | "pattern" => PatternExtension(node)
             | _ => null
         }
     }
  }
  
  module AttrUtils
  {
      public Attr(this attrs : IEnumerable[AttributeNode],  name : string) : AttributeNode
      {
         attrs.FirstOrDefault(a => a.Name == name)
      }
  }
  
  class MatchExtension : ISparkExtension
  {
      node : ElementNode;
      
      public this(node : ElementNode)
      {
          this.node = node;
      }
      
      static emptyChars = " \t\n\r";
      public VisitNode(_visitor : INodeVisitor, _body : IList[Node], _chunks : IList[Chunk]) : void
      {
          def isEmptyNode(n)
          {
              n.Text.All(emptyChars.Contains(_));
          }
          
          def removeEmptyLiterals(nodes)
          {
              | (x is TextNode) :: tail when isEmptyNode(x) =>
                    removeEmptyLiterals(tail)
              | x :: tail => 
                    x :: removeEmptyLiterals(tail)
              | [] => 
                    []
          }
          
          _visitor.Accept(removeEmptyLiterals(_body.AsList()).ToList());
      }

      public VisitChunk(visitor : IChunkVisitor, location : OutputLocation, chunks : IList[Chunk], output : StringBuilder) : void 
      {
          when (location == OutputLocation.RenderMethod)
          {
              def expr = node.Attributes.Attr("expr");
              
              when (expr == null)
                throw CompilerException("requre match expression in expr attribute");

              _ = output.AppendLine($"match ($(expr.Value)) {");
              visitor.Accept(chunks);
              _ = output.AppendLine("}");
          }
      }
  }

  class PatternExtension : ISparkExtension
  {
      node : ElementNode;
      
      public this(node : ElementNode)
      {
          this.node = node;
      }
      
      public VisitNode(visitor : INodeVisitor, body : IList[Node], _chunks : IList[Chunk]) : void
      {
          visitor.Accept(body)
      }

      public VisitChunk(visitor : IChunkVisitor, location : OutputLocation, chunks : IList[Chunk], output : StringBuilder) : void 
      {
          when (location == OutputLocation.RenderMethod)
          {
              def expr = node.Attributes.Attr("expr");
              
              when (expr == null)
                throw CompilerException("requre match pattern in expr attribute");

              _ = output.AppendLine($"| $(expr.Value) => {");
              visitor.Accept(chunks);
              _ = output.AppendLine("}");
          }
      }
  }
}
