// Copyright 2008-2009 Louis DeJardin - http://whereslou.com
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
using System.Collections.Generic;
using System.Linq;
using Spark.Compiler;
using Spark.Compiler.NodeVisitors;
using Spark.Parser;
using Spark.Parser.Markup;
using Spark;
using Nemerle.Contrib;

namespace NRails.Spark.NodeVisitors
{
    public class NemerleSpecialNodeVisitor : AbstractNodeVisitor
    {
        _containingNames : IList[string] = array[
            "def", "def", "default", "for", "use", "content", "test", "if", "else", "elseif", "macro", "render", "section", "cache", 
            "match"
        ];
        _nonContainingNames : IList[string] = array[
            "global", "set", "viewdata"
        ];

		_extensionNodes : Stack[ExtensionNode] = Stack.[ExtensionNode]();

        mutable _nodes : IList[Node] = List.[Node]();
        _stack : Stack[IList[Node]] = Stack.[IList[Node]]();

        public this(context : VisitorContext)
        {
            base(context)
        }

        public override Nodes : IList[Node]
        {
            get { _nodes; }
        }

        private Add(node : Node) : void 
        {
            Nodes.Add(node);
        }

        private PushSpecial(element : ElementNode) : void
        {
            def special = SpecialNode(element) with { OriginalNode = element };
            Nodes.Add(special);
            _stack.Push(Nodes);
            _nodes = special.Body;
        }

        private PopSpecial(name : string) : void 
        {
            when (_stack.Count == 0)
                throw CompilerException(string.Format("Unexpected end element {0}", name));

            _nodes = _stack.Pop();
            
            match (Nodes.Last())
            {
                | special is SpecialNode => 
                   when (special.Element.Name != name)
                     throw CompilerException(string.Format("End element {0} did not match {1}", name, special.Element.Name));
                | _ =>
                    throw CompilerException(string.Format("Unexpected end element {0}", name));
            }
        }

        mutable _acceptNodesLevel = 0;
        protected override BeforeAcceptNodes() : void 
        {
            _acceptNodesLevel++;
        }
        protected override AfterAcceptNodes() : void
        {
            _acceptNodesLevel--;
            when (_acceptNodesLevel == 0)
            {
                when (_stack.Count != 0)
                {
                    def specialNode = _stack.Peek().Last() :> SpecialNode;
                    
                def paint = Context.Paint.OfType.[Paint[Node]]()
                        .FirstOrDefault(p => (p.Value : object) == specialNode.OriginalNode);
                    
                    def position = if (paint == null) null else paint.Begin;
                    
                    throw CompilerException(
                        string.Format("Element {0} was never closed", specialNode.Element.Name), 
                        position);
                }
            }
        }

        protected override Visit(node : ElementNode) : void 
        {
            mutable extension : ISparkExtension;
            if (IsContainingElement(node.Name, node.Namespace))
            {
                PushSpecial(node);
                when (node.IsEmptyElement)
                    PopSpecial(node.Name);
            }
            else if (IsNonContainingElement(node.Name, node.Namespace))
            {
                PushSpecial(node);
                PopSpecial(node.Name);
            }
            else if (TryCreateExtension(node, out extension))
            {
                def extensionNode = ExtensionNode(node, extension);
                Nodes.Add(extensionNode);

                when (!node.IsEmptyElement)
                {
					_extensionNodes.Push(extensionNode);
                    _stack.Push(Nodes);
                    _nodes = extensionNode.Body;
                }
            }
            else if (IsPartialFileElement(node.Name, node.Namespace))
            {
                def attributes = List.[AttributeNode](node.Attributes);
                attributes.Add(AttributeNode("file", "_" + NameUtility.GetName(node.Name)));
                def useFile = ElementNode("use", attributes, node.IsEmptyElement) with
                                  {
                                      OriginalNode = node
                                  };
                PushSpecial(useFile);
                when (node.IsEmptyElement)
                    PopSpecial("use");
            }
            else
            {
                Add(node);
            }
        }

        private IsContainingElement(name : string, ns : string) : bool
        {
            if (Context.Namespaces == NamespacesType.Unqualified)
                _containingNames.Contains(name);
            else if (ns != Constants.Namespace)
                false;
            else
                _containingNames.Contains(NameUtility.GetName(name));
        }

        private IsNonContainingElement(name : string, ns : string) : bool 
        {
            if (Context.Namespaces == NamespacesType.Unqualified)
                _nonContainingNames.Contains(name);
            else if (ns != Constants.Namespace)
                false;
            else
                _nonContainingNames.Contains(NameUtility.GetName(name));
        }

        private IsPartialFileElement(name : string, ns : string) : bool 
        {
            if (Context.Namespaces == NamespacesType.Unqualified)
                Context.PartialFileNames.Contains(name);
            else if (ns != Constants.Namespace)
                false;
            else
                Context.PartialFileNames.Contains(NameUtility.GetName(name));
        }


        private TryCreateExtension(node : ElementNode, extension : out ISparkExtension) : bool
        {
            if (Context.ExtensionFactory == null)
            {
                extension = null;
                false;
            }
            else
            {
                extension = Context.ExtensionFactory.CreateExtension(Context, node);
                extension != null;
            }
        }


        protected override Visit(node : EndElementNode) : void 
        {
            if (_extensionNodes.Count > 0 &&
                string.Equals(node.Name, _extensionNodes.Peek().Element.Name))
            {
                _nodes = _stack.Pop();
				_ = _extensionNodes.Pop();
            }
            else if (IsContainingElement(node.Name, node.Namespace))
            {
                PopSpecial(node.Name);
            }
            else if (IsNonContainingElement(node.Name, node.Namespace))
            {
                // non-contining names are explicitly self-closing
            }
            else if (IsPartialFileElement(node.Name, node.Namespace))
            {
                PopSpecial("use");
            }
            else
            {
                Add(node);
            }
        }

        protected override Visit(attributeNode : AttributeNode) : void
        {
            Add(attributeNode);
        }

        protected override Visit(textNode : TextNode) : void 
        {
            Add(textNode);
        }

        protected override Visit(node : ExpressionNode) : void
        {
            Add(node);
        }

        protected override Visit(entityNode : EntityNode) : void
        {
            Add(entityNode);
        }

        protected override Visit(docTypeNode : DoctypeNode) : void
        {
            Add(docTypeNode);
        }

        protected override Visit(_ : SpecialNode) : void
        {
            throw System.NotImplementedException();
        }

        protected override Visit(_ : ExtensionNode) : void
        {
            throw System.NotImplementedException();
        }

        protected override Visit(commentNode : CommentNode) : void
        {
            Add(commentNode);
        }

        protected override Visit(node : StatementNode) : void
        {
            Add(node);
        }

        protected override Visit(_ : ConditionNode) : void
        {
            throw System.NotImplementedException();
        }

        protected override Visit(node : XMLDeclNode) : void
        {
            Nodes.Add(node);
        }

        protected override Visit(node : ProcessingInstructionNode) : void
        {
            Nodes.Add(node);
        }
    }
}
